# 结题报告

## 小组成员

* 于宛扬（组长）
* 杨玺禾
* 韩思琦
* 贾钰珩

# 目录


- [结题报告](#结题报告)
- [目录](#目录)
  - [引言](#引言)
    - [项目背景](#项目背景)
      - [一、技术背景](#一技术背景)
        - [1.用户行为建模的逐步成熟](#1用户行为建模的逐步成熟)
        - [2.大模型 + LoRA 微调的有效融合](#2大模型--lora-微调的有效融合)
        - [3.系统层集成与自动化反馈的趋势](#3系统层集成与自动化反馈的趋势)
      - [二、已有商业案例对比参考](#二已有商业案例对比参考)
    - [项目成果概述](#项目成果概述)
  - [项目总体架构](#项目总体架构)
    - [整体架构](#整体架构)
    - [主要技术路线](#主要技术路线)
  - [各模块技术细节](#各模块技术细节)
    - [数据收集与处理](#数据收集与处理)
      - [过滤系统进程](#过滤系统进程)
      - [隐私保护](#隐私保护)
    - [LLM微调](#llm微调)
      - [大模型微调背景](#大模型微调背景)
      - [LoRA（Low-Rank Adaptation）技术原理](#loralow-rank-adaptation技术原理)
      - [LoRA 的优点](#lora-的优点)
      - [数据集对预测结果的影响](#数据集对预测结果的影响)
      - [Fine-tunning参数的选择](#fine-tunning参数的选择)
        - [设备信息](#设备信息)
        - [**第一轮 (实验1-10)：全面探索**](#第一轮-实验1-10全面探索)
        - [**第二轮 (实验11-16)：精准优化**](#第二轮-实验11-16精准优化)
        - [**第三轮 (实验17-19)：极限边界测试**](#第三轮-实验17-19极限边界测试)
        - [**最终结论**](#最终结论)
          - [**总结**](#总结)
          - [**关键洞察**](#关键洞察)
        - [**调参策略总结**](#调参策略总结)
          - [**1. 探索顺序策略**](#1-探索顺序策略)
          - [**2. 参数重要性层次**](#2-参数重要性层次)
          - [**3. 资源与效果平衡**](#3-资源与效果平衡)
          - [**4. 经验性发现**](#4-经验性发现)
          - [**5. 调参哲学总结**](#5-调参哲学总结)
    - [端到端用户行为预测和应用优化系统](#端到端用户行为预测和应用优化系统)
      - [系统概述](#系统概述)
      - [环境要求](#环境要求)
      - [配置文件说明(json)](#配置文件说明json)
      - [系统启动流程](#系统启动流程)
      - [故障排除](#故障排除)
      - [调试模式](#调试模式)
      - [性能调优](#性能调优)
      - [系统监控](#系统监控)
      - [开发指南](#开发指南)
      - [安全注意事项](#安全注意事项)
    - [模拟强化学习调度](#模拟强化学习调度)
      - [实现背景](#实现背景)
      - [实现原理](#实现原理)
      - [核心代码](#核心代码)
  - [实验结果](#实验结果)
    - [微调结果展示](#微调结果展示)
    - [端到端用户行为预测和应用优化系统成果展示](#端到端用户行为预测和应用优化系统成果展示)
    - [模拟强化学习调度展示](#模拟强化学习调度展示)
      - [实现流程](#实现流程)
  - [总结](#总结-1)
    - [项目总结回顾](#项目总结回顾)
      - [项目成果：](#项目成果)
      - [收获](#收获)
      - [优化空间：](#优化空间)
    - [未来工作展望](#未来工作展望)
      - [强化学习：让机器在试错中进化的智能之路](#强化学习让机器在试错中进化的智能之路)
  - [贯性对当前模型输出的优劣进行判断。](#贯性对当前模型输出的优劣进行判断)
  - [References](#references)

## 引言

### 项目背景
随着人工智能技术的快速发展，尤其是大语言模型（如LLaMA、Qwen、ChatGPT 等）在自然语言处理、上下文建模、意图理解等方面的突破，人机交互系统正逐步从“被动响应”向“主动预测”演进。传统的应用程序或操作系统仅在用户发出明确指令后执行操作，而随着用户对效率和智能化的期待不断提高，能够预判用户需求并提前执行操作的系统显得尤为重要。

本项目的核心目标是：利用大模型对用户的历史操作行为进行学习，从而预测其未来的操作，并进行智能反馈或预执行操作，从而优化用户体验和交互效率。

#### 一、技术背景

##### 1.用户行为建模的逐步成熟
在移动应用、操作系统和网页行为分析等领域，用户行为数据早已被广泛用于分析使用偏好和优化界面设计。然而传统方法多依赖于统计模型或浅层机器学习算法，难以捕捉长程依赖和复杂语义关系。而大模型特别是因上下文感知能力强、对多模态输入具备适配性的优势，已成为建模用户序列数据的理想选择。

##### 2.大模型 + LoRA 微调的有效融合
大模型虽强，但部署成本高，训练门槛高。Low-Rank Adaptation (LoRA) 提供了一种轻量级、低资源开销的参数微调方式，使得我们能够在保留大模型泛化能力的同时，专注于用户特定数据的学习，这对于个性化预测尤其重要。

##### 3.系统层集成与自动化反馈的趋势

随着本地大模型部署工具（如 llama.cpp、vLLM）与操作系统接口（如 Windows API、macOS Automation）的打通，未来可以实现“预测即响应”的闭环操作体验，例如在你即将打开某网页或文件前，系统就已预加载内容甚至提前打开目标应用。

#### 二、已有商业案例对比参考
* Google Now / Google Assistant：通过分析用户日程、搜索、位置数据提供“预测性卡片”，但模型粒度不够个性化，无法基于本地应用行为细粒度预测。
* Apple Siri Suggestions：能基于近期 App 使用习惯进行建议，但其模型为黑盒，无法在本地个性化训练或嵌入微调机制。

相比之下，本项目的优势在于：
* 使用LoRA 微调后的大语言模型，具备更强上下文理解与泛化能力；
* 基于真实用户的时间操作序列数据进行建模，更具个性化；
* 可集成到本地系统中形成完整闭环，实现预测—执行一体化。
### 项目成果概述

在[调研报告](https://github.com/OSH-2025/MEMO/blob/main/research_report/research_report.md)中，我们写道：

> MEMO基于LLM与LSTM（长短期记忆网络）等模型，通过提取程序使用数据中的上下文信息来预测用户软件使用行为，实现PC端优化Linux内存管理调度，提升用户体验。

随着调研和实践逐步深入，我们对项目做出了一些调整。在中期报告后，我们采纳邢凯老师的建议，放弃LSTM等小模型，使用LLM微调作为预测主体（补充撰写了相关的可行性报告）。

为了微调LLM，我们首先编写了`data_collection`模块来收集和处理数据，由于小组成员的主要文件操作都发生在Windows下，所以优化目标也由Linux改为Windows（未来可以扩展为MacOS、Linux等）。

项目核心架构包含四个关键模块：
1. 数据采集与处理模块负责实时收集用户操作数据，进行清洗标注形成训练集；
2. 模型微调模块基于预训练大语言模型进行领域适配，使其具备用户行为序列预测能力；
3. 调度+整合模块实时分析当前操作上下文，预测并触发相关应用程序或网页的提前加载，同时评估预测准确性。为了提高正确率以及用户体验，我们尝试了以星期为周期进行预测，并添加了人为纠错功能。

系统通过持续学习用户的文件操作、应用使用和网页浏览行为，预测用户下一步可能的操作需求，主动进行资源预加载。

## 项目总体架构

### 整体架构
![architecture](/final_report/asset/architecture.png)
### 主要技术路线
![alt text](/final_report/asset/主要技术路线.png)


## 各模块技术细节

### 数据收集与处理
下图展示了数据收集的主要流程：
![alt text](/final_report/asset/data.png)

针对网页或软件等不同的数据类型，我们采取了不同的收集策略和触发机制，共同构成了完整的用户活动画像。其中，时间上下文作为"时间标尺"，为其他活动数据提供了重要的时间维度信息。

当用户选择采集数据时，activity_monitor.py会持续监控用户的各种活动，实现多维度数据收集。收集内容主要包括窗口焦点变化、进程启动与结束操作、浏览器历史记录、文件访问操作以及时间上下文（例如星期）等信息。

#### 过滤系统进程
某些系统进程是用户在使用软件中自动产生的，而不是用户自己愿意启动的。预测这样的应用启动是没有意义的，因此我们在数据处理的过程中会自动屏蔽这样的系统应用。
#### 隐私保护
- 所有数据本地处理，不上传云端
- 敏感URL和信息自动过滤
- 用户可控制监控范围和数据保留时间

收集到的数据可以通过activity_analyzer.py进行处理。我们首先对数据进行预处理，将序列分段，按照5min作为一个阶段进行划分。我们提取这些数据的特征，进行了数据集的生成和可视化展示。展示结果如下所示。
![alt text](/final_report/asset/file_extensions.png)
![alt text](/final_report/asset/weekday_activity.png)
![alt text](/final_report/asset/top_domains.png)
![alt text](/final_report/asset/top_apps.png)
![alt text](/final_report/asset/hourly_activity.png)
![alt text](/final_report/asset/app_durations.png)
![alt text](/final_report/asset/activity_heatmap.png)



### LLM微调

#### 大模型微调背景
大规模预训练语言模型（如 LLaMA、Qwen、GPT 等）通常具备强大的泛化能力，但它们的参数规模巨大（通常数亿至数千亿参数），训练和更新成本高昂。直接对整个大模型进行微调：
* 需要大量计算资源和显存，
* 容易导致“灾难性遗忘”，使模型丧失原有通用知识，
* 微调后的模型体积庞大，部署困难。

因此，在实际应用中，往往采用更高效的微调技术，使模型能针对特定任务或领域快速适应，同时保留原模型权重不变。

#### LoRA（Low-Rank Adaptation）技术原理
LoRA 是一种近年来提出的轻量级微调方法，主要思想是在保持预训练模型主权重不变的基础上，仅学习一小部分低秩矩阵参数，以调整模型的表达能力。

具体原理如下：
* 对 Transformer 中的权重矩阵 $W_0\in \mathbb{R}^{m\times n}$ （例如查询、键、值矩阵）进行微调时，不直接更新 $W_0$ ，而是用两个低秩矩阵 $A\in \mathbb{R}^{m\times r}$， $B\in \mathbb{R}^{r\times m}$ 来近似微调参数增量，
* 微调后的权重表示为：
 $W_1=W_0+\Delta W=W_0+A\cdot B$
  其中 $r\ll\mathrm{min}\{m,n\}$ ，即秩远小于矩阵维度，显著减少需要训练的参数量。
* 训练时只更新 $A$ 和 $B$ ，主权重 $W_0$保持冻结。

#### LoRA 的优点
* 参数量少，训练效率高

  只需训练低秩矩阵，参数量减少数百倍以上，显著节省显存和计算资源。
* 避免灾难性遗忘

  主模型权重保持不变，微调时保留原有知识，增强泛化能力。
* 易于集成和部署

  微调参数是增量权重，可以方便地与原始模型融合或分开存储，实现模块化更新。
* 适合个性化和增量训练

  对不同用户或任务可训练独立的低秩矩阵，支持模型快速适配。

#### 数据集对预测结果的影响
**预测正确率的计算方法**
1. 如果pred和ref相等，则正确数加1。
2. 如果仅仅预测目标正确，预测操作正确，只是时间不正确，则部分正确数加1。
3. 总体准确率根据完全正确的取1计算；部分正确的取0.5计算。最后累加计算预测正确的结果。
![alt text](/final_report/asset/预测准确率.png)

**用户行为随预测准确率的变化趋势**
![alt text](/final_report/asset/趋势.png)
如上图所示，随数据集大小的增长，用户行为预测准确率显著上升。目前由于我们的采集的数据有限，预测准确率还不够理想。可以合理推断，如果数据量足够，预测的准确率应该会有显著增长。
#### Fine-tunning参数的选择

##### 设备信息

Linux

GeForce RTX 4090 *2



Python 3.12.9



> 为了减少单个训练的时间，调参时只使用了部分数据集



```sh
#!/bin/bash
set -e

echo "开始运行10个不同配置的训练实验..."

# 实验1：基础配置 - 中等学习率，小batch
echo "=== 实验1：基础配置 ==="
python train.py \
    --per_device_train_batch_size 2 \
    --per_device_eval_batch_size 2 \
    --max_length 512 \
    --learning_rate 0.0002 \
    --lora_r 8 \
    --lora_alpha 32 \
    --lora_dropout 0.1 \
    --gradient_accumulation_steps 4 \
    --num_train_epochs 3 \
    --output_dir output/exp1_lr0.0002_bs2_r8_a32 \
    --data_dir data

```



##### **第一轮 (实验1-10)：全面探索**

**目标**：确定关键超参数的大致范围

| 实验号 | 参数修改策略                    | 结果   | 结果分析                 |
| ------ | ------------------------------- | ------ | ------------------------ |
| exp1   | 基础配置 (lr=0.0002, bs=2, r=8) | 0.2989 | 建立baseline，表现良好   |
| exp2   | 降低学习率 (lr=0.0001)          | 0.2793 | 学习率过低，收敛不充分   |
| exp3   | 增大batch size (bs=4)           | 0.2877 | 大batch反而降低效果      |
| exp4   | 增大LoRA rank (r=16, a=64)      | 0.2709 | 中等rank效果一般         |
| exp5   | 提高学习率 (lr=0.0005)          | 0.2989 | 达到最优，学习率可以更高 |
| exp6   | 组合优化 (低lr+大bs+大r)        | 0.2793 | 多参数组合未带来提升     |
| exp7   | 增大dropout (d=0.2)             | 0.2709 | 过度正则化，效果下降     |
| exp8   | 梯度累积策略 (bs=1, gs=8)       | 0.2933 | 小幅提升，梯度策略有效   |
| exp9   | 极低学习率 (lr=0.00005)         | 0.2821 | 过于保守，效果中等       |
| exp10  | 大LoRA容量 (r=32, a=128)        | 0.2989 | 大容量达到最优水平       |



**第一轮发现**：

-  学习率最优范围：0.0002-0.0005
-  batch_size=2最稳定
-  LoRA rank越大越好(r=32 > r=8)
-  dropout=0.1合适，0.2过大



#####  **第二轮 (实验11-16)：精准优化**

**目标**：在最优区间内精细搜索

| 实验号 | 参数修改策略                             | 结果       | 结果分析                     |
| ------ | ---------------------------------------- | ---------- | ---------------------------- |
| exp11  | 激进学习率 (lr=0.001)                    | **0.3101** | 🔥 突破性提升！高学习率很有效 |
| exp12  | 高lr+大容量 (lr=0.0005, r=32)            | 0.2765     | 高lr与大模型不兼容           |
| exp13  | 超大容量 (r=64, a=256)                   | 0.2989     | 超大容量遇到收益递减         |
| exp14  | 更多训练轮次 (epochs=5)                  | **0.3073** | 训练轮次很重要！             |
| exp15  | 更长序列 (ml=768, gc=True)               | **0.3045** | 长序列有帮助                 |
| exp16  | 综合最优 (lr=0.0003, r=32, ep=4, d=0.05) | **0.3128** | 🏆 当前最佳配置               |

**第二轮发现**：

-  **最关键发现**：lr=0.001效果很好
-  训练轮次很重要：4-5个epoch > 3个epoch
-  降低dropout到0.05有帮助
-  中等学习率(0.0003)与大模型容量配合更好

##### **第三轮 (实验17-19)：极限边界测试**

**目标**：在最佳配置基础上寻找极限

| 实验号 | 参数修改策略                      | 结果       | 结果分析                           |
| ------ | --------------------------------- | ---------- | ---------------------------------- |
| exp17  | 最佳lr+超大容量 (lr=0.0003, r=64) | 0.3073     | 超大容量无额外收益，r=32已足够     |
| exp18  | 更激进学习率 (lr=0.0015)          | **0.0000** | ❌ 完全失败！学习率过高导致训练崩溃 |
| exp19  | 最佳配置+长序列 (ml=768)          | 0.2905     | 长序列反而降低效果，可能过拟合     |

**第三轮发现**：找到了学习率上界(>0.001会崩溃)，r=32是容量甜蜜点，ml=512最合适



##### **最终结论**

###### **总结**

📊 **完整实验结果表格***最优配置 (exp16)**：

| 编号 | learning_rate | batch_size | lora_r | lora_alpha | lora_dropout | epochs | grad_accum | max_length | grad_checkpoint | overall_accuracy |
| ---- | ------------- | ---------- | ------ | ---------- | ------------ | ------ | ---------- | ---------- | --------------- | ---------------- |
| 1    | 0.0002        | 2          | 8      | 32         | 0.1          | 3      | 4          | 512        | False           | **0.2989**       |
| 2    | **0.0001**    | 2          | 8      | 32         | 0.1          | 3      | 4          | 512        | False           | 0.2793           |
| 3    | 0.0002        | **4**      | 8      | 32         | 0.1          | 3      | 4          | 512        | False           | 0.2877           |
| 4    | 0.0002        | 2          | **16** | 64         | 0.1          | 3      | 4          | 512        | False           | 0.2709           |
| 5    | 0.0005        | 2          | 8      | 32         | 0.1          | 3      | 4          | 512        | False           | 0.2989           |
| 6    | 0.0001        | **4**      | **16** | 64         | 0.1          | 3      | 4          | 512        | False           | 0.2793           |
| 7    | 0.0002        | 2          | 8      | 32         | 0.2          | 3      | 4          | 512        | False           | 0.2709           |
| 8    | 0.0002        | **1**      | 8      | 32         | 0.1          | 3      | 8          | 512        | False           | 0.2933           |
| 9    | 0.00005       | 2          | 8      | 32         | 0.1          | 3      | 4          | 512        | False           | 0.2821           |
| 10   | 0.0001        | 2          | 32     | 128        | 0.1          | 3      | 4          | 512        | False           | 0.2989           |
| 11   | 0.001         | 2          | 8      | 32         | 0.1          | 3      | 4          | 512        | False           | **0.3101**       |
| 12   | 0.0005        | 2          | 32     | 128        | 0.1          | 3      | 4          | 512        | False           | 0.2765           |
| 13   | 0.0002        | 2          | 64     | 256        | 0.1          | 3      | 4          | 512        | False           | 0.2989           |
| 14   | 0.0002        | 2          | 8      | 32         | 0.1          | 5      | 4          | 512        | False           | 0.3073           |
| 15   | 0.0002        | 2          | 8      | 32         | 0.1          | 3      | 4          | 768        | True            | 0.3045           |
| 16   | 0.0003        | 2          | 32     | 128        | 0.05         | 4      | 4          | 512        | False           | **0.3128**       |
| 17   | 0.0003        | 2          | 64     | 256        | 0.05         | 4      | 4          | 512        | False           | 0.3073           |
| 18   | 0.0015        | 2          | 32     | 128        | 0.05         | 4      | 4          | 512        | False           | **0.0000**       |
| 19   | 0.0003        | 2          | 32     | 128        | 0.05         | 4      | 4          | 768        | True            | 0.2905           |

```
learning_rate = 0.0003
lora_r = 32
lora_alpha = 128  
num_train_epochs = 4
lora_dropout = 0.05
per_device_train_batch_size = 2
max_length = 512
```

###### **关键洞察**

1. **学习率甜蜜点**：0.0003-0.001，超过0.001会训练崩溃
2. **LoRA容量策略**：r=32最佳，r=64无额外收益
3. **训练策略**：4个epoch性价比最高
4. **序列长度**：512比768更稳定
5. **正则化**：dropout=0.05比0.1更好

#####  **调参策略总结**

###### **1. 探索顺序策略**

```
单变量控制 → 最优区间确定 → 多变量组合 → 极限边界测试
```

###### **2. 参数重要性层次**

```
学习率 > 训练轮次 > LoRA容量 > 序列长度 > batch_size > dropout
```

###### **3. 资源与效果平衡**

- **计算资源考虑**：bs=2平衡显存与效果
- **训练时间考虑**：epoch=4-5性价比高
- **存储考虑**：大LoRA rank值得额外存储开销

###### **4. 经验性发现**

- **学习率甜蜜点**：0.0003-0.001（比常规认知更高）
- **LoRA容量策略**：宁大勿小，r=32明显优于r=8
- **训练策略**：多epoch胜过复杂超参数调整

这个调参过程体现了**系统性实验设计**的重要性：从粗到细，从单变量到多变量，最终找到最优配置！

###### **5. 调参哲学总结**

- **系统性探索** > 随机尝试
- **单变量控制** → **最优区间确定** → **多变量组合** → **极限边界测试**
- **简单有效的改进**（如增加epoch）往往比复杂的超参数组合更有效
- **要敢于尝试违反常规的参数**（如高学习率0.001）

最终达到 **overall_accuracy = 0.3128**，相比初始baseline提升了约4.6%！















### 端到端用户行为预测和应用优化系统

#### 系统概述

本系统是一个智能的用户行为预测系统，通过监控用户在Windows上的应用使用模式，利用部署在Linux云服务器上的大语言模型进行预测，并提前预加载用户可能要使用的应用程序，从而提升用户体验。



#### 环境要求

> **Windows端**
>- Python 3.8+
>- 必需库：`psutil`, `pywin32`, `requests`, `threading`
>- 支持SSH客户端（Windows 10/11自带）

> **Linux云服务器**
>- Python 3.8+
>- PyTorch + Transformers
>- FastAPI + Uvicorn
>- 微调后的LLM模型



#### 配置文件说明(json)

```r

{
  "system": {
    "queue_size": 10,              // 活动队列大小
    "prediction_window": 5,        // 预测窗口大小
    "prediction_cooldown": 30,     // 预测冷却时间(秒)
    "confidence_threshold": 0.6    // 预加载置信度阈值
  },
  "llm": {
    "use_ssh_tunnel": true,        // 是否使用SSH隧道
    "server_host": "js2.blockelite.cn",
    "server_port": 8000,
    "timeout": 15
  },
  "ssh": {
    "host": "js2.blockelite.cn",   // 云服务器地址
    "port": 17012,                 // SSH端口 (新端口)
    "username": "root",
    "tunnel_local_port": 8000,     // 本地隧道端口
    "tunnel_remote_port": 8000     // 远程隧道端口
  }
}
```

#### 系统启动流程

1. 启动云服务器LLM服务

```r
ssh root@js2.blockelite.cn -p 17012
cd /home/vipuser/llm
python model_api_server.py
```

2.  建立SSH隧道（新窗口）

```r
ssh -L 8000:localhost:8000 root@js2.blockelite.cn -p 17012
```

3. 启动Windows端系统（再开新窗口）

```r
python end_to_end_system.py
```

4.  系统运行状态

正常运行时，你会看到：

```r
🎯 端到端用户行为预测和应用优化系统
======================================

✅ 云服务器LLM模型已就绪
🚀 系统启动中...
📊 开始监控用户活动...
🔮 LLM预测服务已就绪...

📊 新活动: 2025-06-28 22:30:15 - 切换到窗口: Chrome (应用: chrome.exe)
🔮 开始预测，基于最近 5 个活动
✅ 解析成功: Code.exe 在 22:32:15
⏰ 将在 120.0 秒后预加载应用 Code.exe
```

支持的应用

- Code.exe - Visual Studio Code
- chrome.exe - Google Chrome
- msedge.exe - Microsoft Edge
- explorer.exe - 文件资源管理器
- notepad.exe - 记事本
- calc.exe - 计算器
- QQ.exe - QQ
- WeChat.exe - 微信
- SnippingTool.exe - 截图工具

#### 故障排除

**常见问题**

Q1: SSH连接失败

```r
ssh: connect to host js2.blockelite.cn port 17012: Connection refused
```
**解决办法：**
1. 检查网络连接
2. 确认端口号是否正确（17012）
3. 检查云服务器是否运行

 Q2: SSH隧道建立失败

```r
bind [127.0.0.1]:8000: Address already in use
```

**解决办法：**
本地8000端口被占用 ,关闭其他占用8000端口的程序：

```r
netstat -ano | findstr :8000
taskkill /PID <PID号> /F
```




Q3: API连接失败

```r
❌ 连接失败: 连接被拒绝
```

**解决办法：**
1. 确认SSH隧道已建立
2. 确认云服务器API服务正在运行
3. 测试本地连接：curl http://localhost:8000/health

Q4: 预测解析失败

```r

❌ 无法解析云服务器预测结果
```
**可能原因以及解决办法：**
1. LLM返回格式不标准，这是正常的。系统会尝试智能提取应用信息
2. 可以降低 confidence_threshold 阈值

Q5: 应用预加载失败
```r

❌ 不支持的应用: xxx.exe
```

**解决办法：**

1. 检查应用是否在支持列表中
2. 确认应用路径在 ApplicationManager 中正确配置


#### 调试模式
启用详细日志，查看日志文件：：

```r
logging.basicConfig(level=logging.DEBUG)
```


#### 性能调优
**系统参数调整**
1. 提高预测频率：

```r
"prediction_cooldown": 15  // 降低到15秒
```

2. 提高预加载门槛：

```r
"confidence_threshold": 0.8  // 提高到0.8
```

3. 增加监控范围：

```r
"queue_size": 15,
"prediction_window": 8
```

4. 网络优化: 使用更稳定的SSH连接：

```r
ssh -L 8000:localhost:8000 -o ServerAliveInterval=60 -o ServerAliveCountMax=3 root@js2.blockelite.cn -p 17012
```

#### 系统监控
**关键指标**
1. 预测成功率: 成功解析的预测比例
2. 应用命中率: 预加载应用被实际使用的比例
3. 响应时间: LLM预测响应时间
4. 资源使用: CPU和内存占用日志分析

```r

# 统计预测成功率

grep "✅ 解析成功" end_to_end_system.log | wc -l

# 统计预加载次数  

grep "🚀 已预加载应用" end_to_end_system.log | wc -l

# 查看最近的错误

grep "ERROR" end_to_end_system.log | tail -10
```

#### 开发指南

**添加新应用支持**

在 ApplicationManager 中添加应用路径：

```r
self.app_executables = {

    # 现有应用...

​    'new_app.exe': r'C:\Path\To\New\App.exe'
}
```

在 _extract_app_from_prediction 中添加识别规则：

```r
app_patterns = {

    # 现有规则...

​    r'New App Name': 'new_app.exe'
}
```

**自定义预测逻辑**

修改 _predict_via_cloud_api 中的指令：

```r
instruction = """
自定义的预测指令...
"""
```

#### 安全注意事项

**1. SSH密钥认证（推荐）：**

```r
ssh-keygen -t rsa -b 4096
ssh-copy-id root@js2.blockelite.cn -p 17012
```

**2. 限制SSH隧道绑定：**

```r

ssh -L 127.0.0.1:8000:localhost:8000 root@js2.blockelite.cn -p 17012
```

**3. 配置防火墙：**

1. 仅允许必要的端口访问
2. 配置云服务器安全组



### 模拟强化学习调度

#### 实现背景

**与星期的关联性**

根据个人的PC使用偏好，我们认为PC软件的使用时间与星期呈现较大的相关性。对于学生和老师而言，由于课程的安排规划常常按照课程表（按照周为单位）进行。因此，他们的PC软件使用情况理应与星期呈现较大的关联性。这一发现不仅仅适用于师生群体。一项发表于PLOS ONE的研究分析了美国得克萨斯州一家大型能源公司789名办公室员工在两年内的电脑使用数据。研究发现：

1. 工作量在一个星期内逐日增加：从周一到周四，员工的电脑使用量（包括打字数量、鼠标点击和滚动）逐渐增加。

2. 周五显著下降：到了周五，尤其是下午，电脑使用量显著减少，打字数量下降了约19%，而打字错误仅减少了1.65%，表明工作效率下降。

这些结果表明，员工在一周的不同工作日中，电脑使用模式存在显著差异，可能受到心理和行为因素的影响。[3] 根据对自身行为的理解以及如上相关研究，我们打算以星期为单位对用户的软件使用进行预测，从而提高预测的准确率。


**纠错机制**
我们在使用中发现，预测失败的惩罚力度较高。首先，站在操作系统的维度，错误的预测会导致不需要执行的程序占用处理器及内存，是一种极大的资源浪费。由于错误的程序占用系统资源，处理器需要把这些程序再调出内存，增加了上下文转换的工作量。在预测不精确的情况下也会为系统带来不菲的开销。

因此我们提出了一种**提前纠错机制**。首先，如果预测结果显示在某时刻应该启用某软件时，在启用软件之前，我们会先询问用户是否需要启动该软件。如果用户同意，那么正常起启动该软件；如果用户不同意，那么不启用该软件，同时会将这一启动操作在启动队列中对应的表项删除。这表示用户认为预测失败，或者认为与自己的使用需求不相符。通过这样的方式，可以实现对预测结果与用户需求的综合考量，在极大程度上优化了用户的体验感。

#### 实现原理
微调的预测结果会被写入prediction_results.csv中，而根据星期为周期的预测结果将会被写入prediction_buffer.csv中。系统调用程序将根据prediction_buffer.csv中的预测结果来执行。prediction_buffer.csv相当于一个在预测和执行中间的缓冲区，给缓冲区的内容对用户是透明的，但是直接的预测结果（prediction_results.csv）对用户不透明。

对于buffer的填充原理，我们采用预测即填充的方式，即根据用户一个周期的使用情况结果会根据用户使用数据的更新不断被写入至这一buffer中。

对于buffer的删除原理，我们考虑了用户的实际使用需求。在系统调用前，我们会提醒用户根据预测结果，有某软件需要被启用，并询问它的需求。如果用户拒绝该请求，不仅这一预测结果不会被执行，它同时会从prediction_buffer.csv中被删除。这样<span style="color:red;">从一定程度上降低了预测失败的惩罚，同时优化了用户的体验。</span>

#### 核心代码
1. 解析prediction_buffer.csv中的内容
![alt text](/final_report/asset/parse.png)

根据预测的条件，我们将prediction_buffer.csv中的条目解析成4个部分。type分成apps和urls两类，分别表示应用和网页。weekday即是启动的星期，time是启用的具体的时间，target对于应用来说是启用的路径，对于网页来说是相应的网址。

2. 预测结果调用前判断
![alt text](/final_report/asset/call.png)
如果星期和时间都对应相等，则会启用相应的软件或者网址。

3. 启动程序/网页
![alt text](/final_report/asset/launch.png)

根据网页或者程序类型的不同，启动网页或者程序。
4. 主循环
![alt text](/final_report/asset/circle.png)

预测程序启用即进入主循环。首先从buffer中不断读取entries；然后解析该entry，提取出对应的时间、路径的网址。如果判断需要启动该程序，则让用户进行选择是否需要启动。如果用户点击yes，则启动该程序，同时把该条目加入updated_entries；如果用户点击no，则不把这一条目加入updated entries。如果还没有到启用时间，则无论如何将这一条目加入到updated entries。这样即实现了模拟删除的过程。


## 实验结果
### 微调结果展示
**Loss函数展示**
![alt text](/final_report/asset/微调.png)

在深度学习训练过程中，我们的Loss函数曲线通常具备以下几个关键特征：

📉 1. 平稳下降趋势（Smooth Decline）

- **训练Loss（Training Loss）** 从较高值开始，随着 epoch 增加逐渐下降。
- **验证Loss（Validation Loss）** 同步下降，整体趋势与训练Loss一致。

> ✅ 理想曲线应平滑，无剧烈波动或锯齿形震荡。



🧠 2. 明确收敛（Clear Convergence）

- Loss值在训练到一定阶段后趋于平稳，不再显著下降。
- 验证Loss也趋于稳定，说明模型在未见过的数据上表现良好。

---

⚠️ 4. 避免没有震荡和异常跳变

- 无震荡（loss来回抖动） → 学习率设置合理。
- 无断崖式下跌 → 没有训练崩溃或过早停止。

---

**预测准确率展示**
![alt text](/final_report/asset/预测准确率.png)
从图中看到，预测准确率有待进一步提升，模拟强化学习的调度方法将优化这一准确率。
### 端到端用户行为预测和应用优化系统成果展示
![alt text](/final_report/asset/result1.png)

如上图所示，该系统能够实现实时端到端用户行为预测和应用优化系统成果展示。

根据用户当前的应用使用情况，该系统能够预测5分钟后用户的使用需求，并进行系统调用。这一预测内容在云服务器上完成，并将预测结果通过SSH接口返回给用户。

### 模拟强化学习调度展示
#### 实现流程

5.29 我们准备以一星期为周期进行软件预测，我们打算收集一星期之内的用户软件使用情况，并按照这一星期之内的用户数据使用情况预测下一星期的用户软件使用情况。<span style="color:red;">目前，我们已经实现了在给定时间下实现软件的成功预测和互联网网站的成功预测!</span>
![成功启用](/final_report/asset/image.png)

6.28 我们实现了从prediction_buffer.csv中读取条目的程序，并且能够根据用户需求重写prediction_buffer.csv，并绘制相应的图形界面。
1. 启动应用程序
![alt text](/final_report/asset/setup.png)
2. 询问用户
![alt text](/final_report/asset/customer.png)

## 总结

### 项目总结回顾
#### 项目成果：
1. 基于我们得到调研结果，本项目首个基于LLM的用户行为预测系统。
2. 验证了大模型在个人助手场景的应用价值
#### 收获
这次大作业任务让我们拥有了完整的AI产品开发实践案例。

#### 优化空间：
1. 预测准确率有待提高
2. 更多用户、更多数据（泛化）
3. 尝试本地模型长期运行
4. 强化学习模块



### 未来工作展望

虽然本项目使用了模拟强化学习的方法进行优化，但是依然存在以下不足。

1. 二等级赋分：不能对预测的准确性进行精细化衡量。
2. 用户需要手动指定“分数”，自动化相对较低。

只有真正的强化学习才能给这一项目带来更大的提升，我们将介绍未来如何使用强化学习优化我们的项目。

#### 强化学习：让机器在试错中进化的智能之路
**一、强化学习概述**

**1. 简述**

强化学习（Reinforcement Learning，RL）是一种与人类学习方式极为相似的机器学习范式。与传统的有监督学习不同，强化学习不是通过一对一的输入输出样本学习映射，而是通过在环境中的“试错”获得反馈信号（奖励），从而学习如何最大化长期收益。

这套机制的核心在于**智能体**（Agent）与**环境**（Environment）之间的交互：智能体在某个状态下采取某个动作，环境据此给出新的状态和奖励。智能体根据奖励不断调整其策略，以期获得更高的累计奖励。

正如《大规模语言模型：从理论到实践》书中指出，强化学习相比于有监督学习，其最大的特点是目标不再是简单的最小化误差，而是最大化**期望累计奖励**，并且智能体必须在探索（试探未知）和利用（选择当前最优）之间权衡。

![alt text](/final_report/asset/framework.png)

**2. 软件预测中得到强化学习核心概念**
>**智能体与环境** ：在预测软件使用的调度场景中，预测软件就是**智能体**（Agent），而用户、它的PC机状态以及软件使用情况就是**环境**（Environment）。用户会根据预测软件的调度行为给予反馈，通常以奖励的形式。

>**状态、行为与奖励** ：每次进行软件预测时，预测系统都会评估当前的**状态**（State），这可能包括用户已经打开的软件和网页。基于这些信息，它会采取某些**动作**（Action），比如打开软件或者网页和关闭软件或者网页。根据软件的预测行为，用户随后会给出一个奖励，这可以是正面的（成功预测），也可以是负面的（失败预测）。

>**策略与价值**：预测软件在进行预测时实际上是在学习一种策略（Policy）。策略可以视为一套指导其如何在特定状态下行动的规则。预测同时，智能体还试图估计**价值函数**，也就是预测在未来采取某一行为所能带来的奖励。

---

**二、强化学习与有监督学习的本质区别**

<span style="color:red;">区别</span>

1. **监督信号的差异**  
   有监督学习需要明确的标签作为“标准答案”，而强化学习只提供奖励（或惩罚）信号，且该信号可能延迟出现（例如走迷宫时，只有走到终点才知道路径是否最短）。

2. **学习目标的差异**  
   有监督学习的目标是拟合给定的输入输出映射，而强化学习要学习的是如何在序列决策中最大化长期奖励。

3. **数据依赖性差异**  
   有监督学习的数据是独立同分布的（i.i.d.），而强化学习的数据是智能体与环境交互的产物，决策会影响后续数据的分布。

<span style="color:red;">优势</span>
> **强化学习比有监督学习更可以考虑整体影响**
> 有监督学习针对单个词元进行反馈，其目
标是要求模型针对给定的输入给出确切的答案。而强化学习是针对整个输出文本进行反馈，并不
针对特定的词元。这种反馈粒度的不同，使得强化学习更适合大语言模型，既可以兼顾表达多样
性，还可以增强对微小变化的敏感性。自然语言十分灵活，可以用多种不同的方式表达相同的语
义。而有监督学习很难支持上述学习方式。强化学习则可以允许模型给出不同的多样性表达。另
外一方面，有监督微调通常采用交叉熵损失做为损失函数，由于总和规则，造成这种损失对个别
词元变化不敏感，如果改变个别的词元，只会对整体损失产生小的影响。但是，一个否定词可以
完全改变文本的整体含义。强化学习则可以通过奖励函数达到同时兼顾多样性和微小变化敏感性
两个方面。

> **强化学习更容易解决幻觉问题**
用户在大语言模型时主要有三类输入：（a）文本型（TextGrounded）：用户输入相关文本和问题，让模型基于所提供的文本生成答案（例如，“本文中提到
的人名和地名有哪些”）；（b）求知型（Knowledge-Seeking）：用户仅提出问题，模型根据内在知识提供真实回答（例如，“流感的常见原因是什么”）；（c）创造型（Creative）：用户提供问题或说明，
让模型进行创造性输出（例如，“写一个关于... 的故事”）。有监督学习算法非常容易使得求知型查
询产生幻觉。在模型并不包含或者知道答案的情况下，有监督训练仍然会促使模型给出答案。而
使用强化学习方法，则可以通过定制奖励函数，将正确答案赋予非常高的分数，放弃回答的答案
赋予中低分数，不正确的答案赋予非常高的负分，使得模型学会依赖内部知识选择放弃回答，从
而在一定程度上缓解模型幻觉问题。

>**强化学习可以更好地解决多轮对话奖励累积问题**
多轮对话能力是大语言模型重要的基
础能力之一，多轮对话是否达成最终目标，需要考虑多次交互过程的整体情况，因此很难使用有
监督学习方法构建。而使用强化学习方法，可以通过构建奖励函数，根据整个对话的背景以及连
贯性对当前模型输出的优劣进行判断。
---

**三、基于人类反馈的强化学习流程**
基于人类反馈的强化学习主要分为**奖励模型训练**和**近端策略优化**两个步骤。

奖励模型通过由人类反馈标注的偏好数据来学习人类的偏好，判断模型回复的有用性以及保证内容的无害性。奖励模型模拟了人类的偏好信息，能够不断地为模型的训练提供奖励信号。在获得奖励模型后，需要借助强化学习对语言模型继续进行微调。

OpenAI 在大多数任务中使用的强化学习算法都是近端
策略优化算法（Proximal Policy Optimization, PPO）。近端策略优化可以根据奖励模型获得的反馈优化模型，通过不断的迭代，让模型探索和发现更符合人类偏好的回复策略。近端策略优化的流程如下图所示。
![alt text](/final_report/asset/PPO.png)

近端策略优化涉及到四个模型：
（1）策略模型（Policy Model），生成模型回复。
（2）奖励模型（Reward Model），输出奖励分数来评估回复质量的好坏。
（3）评论模型（Critic Model），来预测回复的好坏，可以在训练过程中实时调整模型，选择对未来累积收益最大的行为。
（4）参考模型（Reference Model）提供了一个 SFT 模型的备份，帮助模型不会出现过于极端的变化。近端策略优化的实施流程如下：

>(1) 环境采样：策略模型基于给定输入生成一系列的回复，奖励模型则对这些回复进行打分获得
奖励。

>(2) 优势估计：利用评论模型预测生成回复的未来累积奖励，并借助广义优势估计（Generalized
Advantage Estimation，GAE）算法来估计优势函数，能够有助于更准确地评估每次行动的
好处。

> (3) 优化调整：使用优势函数来优化和调整策略模型，同时利用参考模型确保更新的策略不会有
太大的变化，从而维持模型的稳定性。


**四、RL 在大语言模型中的实际应用**

在大型语言模型（LLM）的训练流程中，强化学习是最后也是关键的阶段之一。书中以 OpenAI 的 InstructGPT 和 ChatGPT 为例，阐述了“基于人类反馈的强化学习”（RLHF）的实践流程

1. **先进行大规模的无监督预训练**，得到基础模型，具备语言理解与生成能力。
2. **进行有监督微调（SFT）**，引入人类标注的高质量问答对，模型学会初步服从人类指令。
3. **构建奖励模型（Reward Model）**，根据人类对生成内容的偏好打分，训练一个可以对多个回答进行优劣排序的对比模型。
4. **采用强化学习方法，如 PPO（近端策略优化）**，用奖励模型对语言模型的输出进行优化，进一步提升其输出的相关性、准确性与可接受性。

这一流程的意义在于，它让大模型不仅仅停留在“生成合理句子”，而是更贴近人类的意图，符合人类的价值观。

---

**五、强化学习的数学基础与典型算法**

**1. 马尔可夫决策过程（MDP）**

强化学习通常建立在马尔可夫决策过程的数学框架之上。MDP 的四要素包括：

- 状态集 `S`
- 动作集 `A`
- 状态转移概率 `P(s'|s,a)`
- 奖励函数 `R(s,a)`

智能体的目标是找到最优策略 π(a|s)，最大化从当前状态开始的期望累计奖励。

---

**2. 价值函数与策略**

强化学习通过**价值函数（Value Function）**来度量状态或状态-动作对的好坏。常见的有：

- 状态价值函数 V^π(s)
- 行动价值函数 Q^π(s,a)

这些函数用于指导策略的改进，如**策略迭代（Policy Iteration）**或**值迭代（Value Iteration）**。

---

**3. 策略梯度与近端策略优化（PPO）**

书中重点介绍了近年来在 RLHF 中应用广泛的**近端策略优化（Proximal Policy Optimization，PPO）**:contentReference[oaicite:3]{index=3}。

PPO 是一种基于策略梯度的方法，旨在避免在策略更新时出现过大变动，导致模型性能大幅波动。其核心思想是通过限制策略更新的步长（clip）来保证每次更新都足够平滑，提高训练的稳定性。

相比早期的 REINFORCE 算法或 Trust Region Policy Optimization（TRPO），PPO 实现更简单、收敛更稳定，因此被广泛用于大语言模型的 RLHF 阶段。

---

**六、奖励建模与数据标注挑战**

强化学习在大语言模型中的一个难点是奖励模型的构建与标注过程。

如书中所述，奖励模型需要对相同提示词下模型生成的不同回复进行质量排序。这一对比标注需要人类在细微表述差异中给出一致的优劣判断，耗费人力且需要严格的标注规范:contentReference[oaicite:4]{index=4}。

此外，奖励模型本身如果泛化能力过强，可能会把生成任务直接学习为判别任务，导致“奖励模型训练等价于重新造一个生成模型”的悖论。因此，如何限定奖励模型的适用边界也是学术界正在研究的重要问题。

---


**七、从 AlphaGo 到 ChatGPT：RL 的典型里程碑**

强化学习的标志性应用莫过于 DeepMind 的 AlphaGo，其结合蒙特卡罗树搜索（MCTS）与深度强化学习，一举战胜人类围棋顶尖选手，引发全球轰动。

随后 AlphaZero 更将强化学习从围棋推广到围棋、国际象棋、将棋等多个复杂博弈任务，并证明了 RL 在完全信息博弈中的巨大潜力。

近年，随着 ChatGPT、Claude、Gemini 等大语言模型应用落地，RL 逐渐从博弈类问题拓展到更具开放性与不确定性的自然语言交互领域，并在 RLHF 框架下进一步向“对齐人类价值观”迈进。

---

**八、强化学习应用于预测软件使用行为**

强化学习不仅是机器学习三大分支之一（有监督学习、无监督学习、强化学习），更是让 AI 从“模式识别”走向“自我试错学习”的关键桥梁。它让智能体在复杂、动态的环境中具备自主决策能力，是实现类人智能不可或缺的重要组成。

从 AlphaGo 的围棋博弈到 ChatGPT 的人机对话，强化学习技术持续推动着 AI 的边界。随着计算能力的提升、算法的优化与数据标注流程的完善，未来强化学习将在自动驾驶、智能机器人、自然语言处理等领域发挥更大的潜力。

根据本项目与环境互动性强的特点，我们的未来工作即是采用强化学习的方法使得模型能够针对用户不断变化的使用模式进行软件预测，从而实现“一机一模型”的终极预测模式。

---



## References

1. Ravenscraft, Eric (2012-10-29). "Google Search Updated, Brings New Google Now Cards And Voice Actions - Yes, You Can Set Calendar Events". Android Police. Retrieved 2012-10-31. https://www.androidpolice.com/2012/10/29/google-search-updated-brings-new-google-now-cards-and-voice-actions-yes-you-can-set-calendar-events/
2. Gartenberg, Chaim (June 5, 2017). "Siri on iOS 11 gets improved speech and can suggest actions based on how you use it". The Verge. Vox Media. Retrieved June 10, 2017. https://www.theverge.com/2017/6/5/15732136/apple-siri-update-announced-new-features-wwdc-2017
3.  Roh, T., Esomonu, C., Hendricks, J., Aggarwal, A., Hasan, N. T., & Benden, M. (2023).  Examining workweek variations in computer usage patterns: An application of ergonomic monitoring software.  *PLOS ONE*, 18(7), e0287976. https://doi.org/10.1371/journal.pone.0287976
4.  张奇、桂韬、郑锐、黄萱菁，大语言模型理论与实践，https://intro-llm.github.io/, 2023.