# 针对数据集的可行性研究报告
小组成员：于宛扬 杨玺禾 韩思琦 贾钰珩

我们希望利用模型的推理能力预测用户文件操作，从而优化内存管理。要达成这个目的，首先需要考虑数据集的构建，需要哪些数据？如何获得数据？如何构建数据集（训练、验证）？模型最终工作的上下文环境是怎样的？
本报告由于宛扬撰写，试图回答以上问题。


- [针对数据集的可行性研究报告](#针对数据集的可行性研究报告)
  - [1. 数据集的构建](#1-数据集的构建)
  - [1.1 获取用户文件操作信息](#11-获取用户文件操作信息)
    - [**系统调用监控**](#系统调用监控)
    - [**文件系统驱动拦截**](#文件系统驱动拦截)
    - [**用户态日志**](#用户态日志)
  - [1.2 获取文件的语义信息](#12-获取文件的语义信息)
    - [上下文增强 —— 要\&\&可获得的信息](#上下文增强--要可获得的信息)
      - [**时间信息**](#时间信息)
      - [**空间信息**](#空间信息)
      - [**元数据**](#元数据)
      - [**语义信息**](#语义信息)
    - [收集方法](#收集方法)
      - [**文件路径提取**](#文件路径提取)
      - [**存储设备信息**](#存储设备信息)
      - [**用户行为模式**](#用户行为模式)
      - [**网络位置**](#网络位置)
      - [**虚拟化环境**](#虚拟化环境)
  - [1.3 对现有LSFS的拓展](#13-对现有lsfs的拓展)
      - [可行技术路径及局限性](#可行技术路径及局限性)
        - [语义提取](#语义提取)
        - [1. **静态分析**](#1-静态分析)
        - [2. **动态行为分析**](#2-动态行为分析)
        - [3. **联网搜索**](#3-联网搜索)
        - [4. **元数据增强**](#4-元数据增强)
        - [语义嵌入](#语义嵌入)
        - [**集成到LSFS**](#集成到lsfs)
      - [**技术难点与解决**](#技术难点与解决)

## 1. 数据集的构建

## 1.1 获取用户文件操作信息

 要获取用户与操作系统交互的信息，尤其是文件操作相关的上下文，需要在操作系统层面进行监控和日志记录。以下是具体方法：

### **系统调用监控**

文件操作（如打开、读取、写入、删除等）通常通过操作系统内核的系统调用实现，例如Linux中的`open()`, `read()`, `write()`, 或Windows中的Win32 API（如`CreateFile()`, `ReadFile()`）。可以通过插入钩子（hooks）或使用现有的系统工具捕获这些调用。例如：

- 在Windows上，可以使用**Windows Event Tracing (ETW)** 或 **Process Monitor**（Sysinternals工具）来实时记录文件系统活动。

- 在Linux上，可以使用`strace`或`eBPF`（Extended Berkeley Packet Filter）来跟踪系统调用。

  

### **文件系统驱动拦截**

开发一个文件系统过滤驱（File System Filter Driver，例如Windows的minifilter）或FUSE（Filesystem in Userspace）模块，拦截用户对文件的操作并提取元数据（如文件路径、操作类型、时间戳等）。

- AIOS的LSFS系统是在元数据的基础上，增加语义数据，此处情景类似，若将LSFS扩展到不同类型的文件（尤其是exe），可以拦截并提取语义数据，作为训练模型的上下文数据集；
- 实际工作中，要在用户下一个操作前做出判断和预处理，但仍要拦截并提取元数据，因为要自我迭代，适应用户长期的习惯

### **用户态日志**

通过应用程序层面的日志收集工具，记录用户在特定软件中的文件操作行为

- 要区分资源收集的粒度，比如资源管理器的操作历史可以收集，但私人应用如某个游戏就不用了吧，记录进程持续时间就行？

## 1.2 获取文件的语义信息

### 上下文增强 —— 要&&可获得的信息

除了用户操作本身，上下文还需要收集文件的时空信息以及元数据，提供给大模型进行语义推理。

初期调研中我们搜集到一些在移动端预测用户行为的工作，这些研究的结论是，时间和空间（真实世界中的经纬度）是影响用户对软件的选择和使用的最终影响。结合大模型基于语义的推理能力，我们断言这正是因为来自现实世界的时间和空间，本身就带有语义。而计算机的特点决定了它难以获得有实际意义的文件操作时空信息——除非定位你在中国科学技术大学计算机科学与技术学院，你每周三一定会打开Vivado，且时间为16:00-18:00——但这特例更接近于嵌入式设计中的固定情景，通用性很差。

语义文件系统的出现预示着这一劣势将被改写，所以势必要将文件系统做语义层面的扩展。PC端我们将空间信息替换为文件的空间信息，即文件的物理和逻辑位置。下面分别对需要获取的各个信息做详细阐释。

#### **时间信息**

  - **时间戳** （如`2025-04-08 14:30:00`）记录操作的发生时刻，属于绝对时间。

    > 时区可能作为时间戳的补充（例如UTC偏移），但在文件操作预测中作用有限，除非涉及跨时区协作（如云文件同步）。作为项目的扩展工作，有待未来画饼。

  - **操作频率** （例如“每分钟5次读操作”）反映时间维度内的行为密度，属于相对时间。

  - 空间信息与时间信息结合，形成完整的“时空上下文”，例如“用户在C盘的项目文件夹中每分钟打开5个文件”。

#### **空间信息**

  - **物理位置**：文件在存储设备上的实际位置，例如硬盘分区（C盘、D盘）、路径层次（`C:\Users\Docs\`）、甚至是分布式存储中的节点位置。
  - **逻辑位置**：文件在操作系统或用户工作流中的语义位置，例如“项目文件夹”“临时文件目录”或“云同步文件夹”。
  - **操作环境**：用户执行操作时的设备、网络状态或虚拟化环境（例如WSL2、VMware）。

####  **元数据**

类型、大小、权限

####  **语义信息**

### 收集方法

时间信息通过和文件操作同步获取，但要增加一个“计数模块”；元数据和语义信息保存在语义文件系统，在1.3中展开讲；下面是物理信息的收集方法：

#### **文件路径提取**

- 通过系统调用（如Windows的`GetFullPathName()`或Linux的`realpath()`）获取文件的完整路径。这不仅提供物理位置，还暗示逻辑语义（例如`/home/user/projects`可能与工作相关）。

#### **存储设备信息**

- 使用操作系统API（如Windows的`GetDriveType()`或Linux的`df`命令）确定文件所在的存储介质（本地硬盘、USB、NAS等）。
- 结合分区信息（如卷标、剩余空间），推断存储优先级或使用场景。

#### **用户行为模式**

- 记录文件操作的上下文，例如用户当前活动的目录（通过`GetCurrentDirectory()`或`pwd`），反映操作的空间倾向。
- 如果涉及多设备同步（如OneDrive），通过API获取云端位置或同步状态。

#### **网络位置**

- 若文件操作涉及远程访问（例如通过SMB或NFS），记录IP地址或域名作为空间信息的一部分。

#### **虚拟化环境**

- 在WSL2或虚拟机中操作时，记录文件在宿主与虚拟系统之间的映射关系（例如`/mnt/c`对应`C:\`）。

## 1.3 对现有LSFS的拓展

AIOS的LSFS（Large-Scale Semantic File System，详见调研报告）利用LLM的语义理解能力，从文件内容中提取语义特征并生成相应的嵌入向量，在传统文件系统上外挂向量数据库，为AIOS提供提示词驱动的文件管理服务。但截至2025年3月，LSFS只能处理文本文件（纯文本或二进制），为了实现我们的内存管理宏图，至少要将其拓展至可执行文件（例如.exe、.dll或ELF文件）。//需要解决可执行文件缺乏显式语义的问题，因为它们是二进制格式而非文本。//先搞清楚为啥不同的文件扩展名处理方式不同 //这一部分的重点，就是可执行文件与文本文件的区别！！（待完善）

#### 可行技术路径及局限性
##### 语义提取

##### 1. **静态分析**
   - 使用逆向工程工具（如IDA Pro、Ghidra）解析可执行文件的结构，提取函数名、导入表、字符串常量等信息。
   - 将这些信息转化为自然语言描述，例如“该文件调用了网络API，可能与网络通信相关”。
   - LLM基于这些描述生成语义标签。
##### 2. **动态行为分析**
   - 在沙盒环境中运行可执行文件（如Cuckoo Sandbox），记录其行为（例如文件读写、网络请求）。
   - 将行为日志输入LLM，推理出操作意图，例如“该程序试图访问用户配置文件”。


方法1、2的准确度或许更高，但时间和计算成本太大，而且用户的应用程序种类极具多样性，不可能为所有可执行程序都手动执行上述过程。或许未来的应用开发者会执行语义概括、上传云端的新工作范式，但当前我们显然需要更高效的解决方案。

试想LSFS由于处理的是用户本地的文本文件，可以直接从里面提取语义信息，是否也是迫不得已？如果LSFS管理的是一个图书馆，需要单独阅读每本书吗？不，一个简单的方法是“作弊”，直接利用联网搜索功能，总结出语义标签。 

##### 3. **联网搜索**


##### 4. **元数据增强**
   - 结合可执行文件的元数据（如数字签名、版本信息、编译时间）以及文件存储路径，生成更丰富的语义上下文。可执行文件存放的位置

  


  
##### 语义嵌入

   - 对上述提取的特征（静态+动态+元数据）使用预训练模型（如BERT或CodeBERT）生成嵌入向量，再输入LLM进行下一步操作预测。
  
##### **集成到LSFS**

   - 将上述语义信息与文件操作日志（时间、路径、用户ID等）结合，扩展LSFS的语义数据库，使其支持可执行文件的语义标注。

#### **技术难点与解决**

- 可执行文件语义不直观：通过多模态输入（文本描述+行为日志）弥补。
- 计算开销大：预处理阶段离线完成，实时操作只调用嵌入结果。新的应用加入后的维护。API调用？
